<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <title>Approach: Limit Radar</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <style>
    :root {
      --bg: #020817;
      --card: #050816;
      --accent: #38bdf8;
      --accent-soft: rgba(56,189,248,0.12);
      --text: #f9fafb;
      --muted: #9ca3af;
      --success: #22c55e;
      --error: #ef4444;
      --border-soft: rgba(148,163,253,0.22);
      --radius-lg: 18px;
      --radius-md: 14px;
      --transition-fast: 0.18s ease;
      --shadow-soft: 0 14px 30px rgba(15,23,42,0.8);
      --font-main: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
    }

    body {
      font-family: var(--font-main);
      background: radial-gradient(circle at top, #020817 0%, #000 70%);
      color: var(--text);
      display: flex;
      justify-content: center;
      align-items: stretch;
      overflow: hidden; /* kritik: scroll yok */
    }

    .app {
      width: 100%;
      max-width: 430px; /* iPhone 15 Pro dikey yakƒ±n */
      height: 100vh;
      margin: 0 auto;
      padding: 10px 10px 8px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      background: radial-gradient(circle at top left,
                   rgba(56,189,248,0.04),
                   rgba(2,6,23,0.98));
      border-radius: 0;
      box-shadow: var(--shadow-soft);
      border-left: 1px solid rgba(15,23,42,0.9);
      border-right: 1px solid rgba(15,23,42,0.9);
      overflow: hidden;
    }

    header {
      flex: 0 0 auto;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .logo-row {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 9px;
      color: var(--muted);
    }

    .logo-mark {
      width: 9px;
      height: 9px;
      border-radius: 999px;
      background: var(--accent);
      box-shadow: 0 0 8px var(--accent);
    }

    h1 {
      font-size: 16px;
      font-weight: 600;
      letter-spacing: 0.02em;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    h1 span {
      font-size: 9px;
      font-weight: 400;
      padding: 1px 6px;
      border-radius: 999px;
      background: var(--accent-soft);
      color: var(--accent);
    }

    .subtitle {
      font-size: 9px;
      color: var(--muted);
    }

    .screen {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      gap: 6px;
      overflow: hidden;
    }

    .card {
      background: radial-gradient(circle at top,
                 rgba(15,23,42,0.96),
                 rgba(2,6,23,1));
      border-radius: var(--radius-md);
      border: 1px solid var(--border-soft);
      padding: 6px 7px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    /* √úst kart: Grafik */
    .card-label {
      font-size: 8px;
      text-transform: uppercase;
      color: var(--accent);
      letter-spacing: 0.14em;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 6px;
    }

    .chip-soft {
      padding: 1px 5px;
      border-radius: 999px;
      background: rgba(9,9,11,1);
      border: 1px solid rgba(56,189,248,0.32);
      font-size: 8px;
      color: var(--accent);
      display: flex;
      align-items: center;
      gap: 3px;
    }

    .canvas-wrap {
      flex: 1 1 auto;
      border-radius: 12px;
      background: radial-gradient(circle at top,
                  rgba(6,8,18,1),
                  rgba(1,4,12,1));
      padding: 3px;
      border: 1px solid rgba(75,85,99,0.85);
      box-shadow: inset 0 0 14px rgba(0,0,0,0.9);
      position: relative;
      overflow: hidden;
    }

    #graphCanvas {
      width: 100%;
      height: 155px; /* iPhone dikey i√ßin sƒ±kƒ± ayar */
      display: block;
      border-radius: 8px;
    }

    .hint-row {
      flex: 0 0 auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 4px;
      font-size: 8px;
      color: var(--muted);
      flex-wrap: nowrap;
    }

    .hint-pill {
      padding: 2px 5px;
      border-radius: 999px;
      border: 1px dashed rgba(148,163,253,0.7);
      font-size: 7px;
      color: var(--muted);
      white-space: nowrap;
    }

    .speed-control {
      display: flex;
      align-items: center;
      gap: 2px;
      font-size: 7px;
      color: var(--muted);
      white-space: nowrap;
    }

    .speed-control label {
      font-size: 7px;
      color: var(--accent);
    }

    .speed-control input[type="range"] {
      -webkit-appearance: none;
      width: 60px;
      height: 4px;
      background: rgba(17,24,39,1);
      border-radius: 8px;
      outline: none;
    }

    .speed-control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 9px;
      height: 9px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 6px rgba(56,189,248,0.8);
      cursor: pointer;
    }

    .speed-control span {
      min-width: 24px;
      text-align: right;
    }

    /* Alt kart: Soru */
    .question-label {
      font-size: 8px;
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }

    .function-label {
      font-size: 10px;
      color: #e5e7eb;
    }

    .limit-label {
      font-size: 11px;
      font-weight: 500;
      color: #fefce8;
      margin-top: 1px;
    }

    .target-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(12,12,16,1);
      border: 1px solid rgba(63,63,70,0.9);
      font-size: 8px;
      color: var(--muted);
      margin-top: 2px;
    }

    .choices {
      margin-top: 4px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 4px;
    }

    .choice-btn {
      padding: 7px 9px;
      border-radius: 10px;
      border: 1px solid rgba(75,85,99,0.95);
      background: radial-gradient(circle at top left,
                  rgba(12,18,30,1),
                  rgba(2,6,23,1));
      color: #e5e7eb;
      font-size: 11px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .choice-btn span.label {
      flex: 1;
    }

    .choice-btn span.key {
      font-size: 8px;
      color: var(--muted);
    }

    .choice-btn:hover {
      border-color: var(--accent);
      box-shadow: 0 0 10px rgba(56,189,248,0.28);
      transform: translateY(-1px);
    }

    .choice-btn.correct {
      border-color: var(--success);
      background: radial-gradient(circle at top left,
                  rgba(22,163,74,0.13),
                  rgba(2,6,23,1));
    }

    .choice-btn.wrong {
      border-color: var(--error);
      background: radial-gradient(circle at top left,
                  rgba(239,68,68,0.16),
                  rgba(2,6,23,1));
    }

    .feedback {
      margin-top: 2px;
      font-size: 9px;
      min-height: 16px;
    }

    .feedback.ok { color: var(--success); }
    .feedback.bad { color: var(--error); }

    .explanation {
      font-size: 8px;
      color: var(--muted);
      margin-top: 1px;
      min-height: 18px;
    }

    .bottom-row {
      margin-top: 3px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 4px;
      font-size: 8px;
      color: var(--muted);
      flex-wrap: nowrap;
    }

    .controls {
      display: flex;
      gap: 4px;
      flex-wrap: nowrap;
    }

    .btn {
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(75,85,99,0.96);
      background: rgba(4,7,17,0.98);
      color: var(--muted);
      font-size: 8px;
      display: inline-flex;
      align-items: center;
      gap: 3px;
      cursor: pointer;
      transition: all var(--transition-fast);
      white-space: nowrap;
    }

    .btn.primary {
      border-color: var(--accent);
      color: var(--accent);
    }

    .btn:hover {
      transform: translateY(-0.5px);
      box-shadow: 0 0 6px rgba(15,23,42,0.9);
    }

    .stats {
      display: flex;
      gap: 6px;
      align-items: center;
      white-space: nowrap;
    }

    .stats span strong {
      color: var(--accent);
      font-weight: 500;
    }

    @media (min-height: 780px) {
      #graphCanvas {
        height: 170px;
      }
    }

    @media (min-width: 768px) {
      .app {
        max-width: 520px;
        border-radius: 22px;
        margin: auto;
      }
      #graphCanvas {
        height: 190px;
      }
    }
  </style>
</head>
<body>
<div class="app">
  <header>
    <div class="logo-row">
      <div class="logo-mark"></div>
      <div>LambdaTechCo ¬∑ Limit Detective</div>
    </div>
    <h1>
      Approach: Limit Radar
      <span>iPhone optimized</span>
    </h1>
    <div class="subtitle">
      Noktalar yakla≈üƒ±rken sadece izle ve hisset:
      <strong>Limit = fonksiyonun hedefi.</strong>
    </div>
  </header>

  <div class="screen">
    <!-- Grafik Kartƒ± -->
    <section class="card" style="flex: 0 0 auto;">
      <div class="card-label">
        <div>G√∂rsel limit sim√ºlat√∂r√º</div>
        <div class="chip-soft"><span>‚óè</span> canlƒ± yakla≈üma</div>
      </div>
      <div class="canvas-wrap">
        <canvas id="graphCanvas" width="390" height="155"></canvas>
      </div>
      <div class="hint-row">
        <div class="hint-pill" id="levelLabel">Seviye 1 ¬∑ S√ºrekli fonksiyon</div>
        <div id="microHint">Noktalar x‚Üía iken f(x)'in nereye gittiƒüini g√∂steriyor.</div>
        <div class="speed-control">
          <label for="speedRange">Hƒ±z</label>
          <input type="range" id="speedRange" min="0.4" max="1.8" step="0.2" value="1.0" />
          <span id="speedLabel">1.0x</span>
        </div>
      </div>
    </section>

    <!-- Soru Kartƒ± -->
    <section class="card" style="flex: 1 1 auto;">
      <div class="question-label">Soru</div>
      <div class="function-label" id="functionLabel">f(x) = 2x + 1</div>
      <div class="limit-label" id="limitPrompt">x ‚Üí 2 iken f(x) hangi deƒüere yakla≈üƒ±yor?</div>
      <div class="target-badge">üéØ Grafiƒüe bak, limit deƒüerini sez.</div>

      <div class="choices" id="choicesContainer"></div>

      <div class="feedback" id="feedback"></div>
      <div class="explanation" id="explanation"></div>

      <div class="bottom-row">
        <div class="controls">
          <button class="btn" id="replayBtn">‚Ü∫ Tekrar izle</button>
          <button class="btn primary" id="nextBtn">‚ñ∂ Sonraki</button>
        </div>
        <div class="stats">
          <span>Seri: <strong id="streak">0</strong></span>
          <span>Doƒüru: <strong id="totalCorrect">0</strong></span>
          <span>Toplam: <strong id="totalAsked">0</strong></span>
        </div>
      </div>
    </section>
  </div>
</div>

<script>
  // --------- Level Definitions ----------
  const levels = [
    {
      id: 1,
      title: "S√ºrekli fonksiyon",
      fnLabel: "f(x) = 2x + 1",
      aLabel: "2",
      a: 2,
      type: "finite",
      xMin: -2,
      xMax: 6,
      yMin: -2,
      yMax: 8,
      fn: x => 2 * x + 1,
      limit: 5,
      options: [3, 5, 7],
      explanation:
        "Polinomlar s√ºreklidir. x ‚Üí 2 iken direkt yerine yazarƒ±z: f(2) = 5, limit de 5.",
      microHint:
        "Noktalar, x=2 yakƒ±nƒ±nda y=5 civarƒ±nda toplanƒ±yor mu, onu izle."
    },
    {
      id: 2,
      title: "Delik ama limit var",
      fnLabel: "f(x) = (x¬≤ - 1)/(x - 1), x ‚â† 1",
      aLabel: "1",
      a: 1,
      type: "finite",
      xMin: -1,
      xMax: 3,
      yMin: -1,
      yMax: 5,
      fn: x => (x === 1 ? NaN : (x * x - 1) / (x - 1)),
      limit: 2,
      options: [1, 2, 0],
      explanation:
        "(x¬≤ - 1)/(x - 1) sadele≈üince x + 1 olur. x ‚Üí 1 iken x + 1 ‚Üí 2. Nokta delik olsa da limit 2.",
      microHint:
        "Delik seni bozmasƒ±n. Yol nereye yakla≈üƒ±yor, ona bak."
    },
    {
      id: 3,
      title: "Saƒü ve sol farklƒ±",
      fnLabel: "f(x) = 1 (x < 0), 3 (x > 0)",
      aLabel: "0",
      a: 0,
      type: "piecewise",
      xMin: -3,
      xMax: 3,
      yMin: 0,
      yMax: 4,
      fnLeft: x => 1,
      fnRight: x => 3,
      limit: null,
      options: ["Limit yok", 1, 3],
      explanation:
        "x ‚Üí 0‚Åª iken f(x)=1, x ‚Üí 0‚Å∫ iken f(x)=3. Saƒü ve sol limit farklƒ± ‚Üí limit yok.",
      microHint:
        "Mavi ve sarƒ± farklƒ± y'lere gidiyorsa: Limit yok."
    },
    {
      id: 4,
      title: "Sonsuzda limit",
      fnLabel: "f(x) = (3x¬≤ + x)/(2x¬≤ + 1)",
      aLabel: "‚àû",
      a: Infinity,
      type: "infinity",
      xMin: 0,
      xMax: 8,
      yMin: 0,
      yMax: 2.5,
      fn: x => (3 * x * x + x) / (2 * x * x + 1),
      limit: 1.5,
      options: [1.5, 3, 0],
      explanation:
        "x b√ºy√ºd√ºk√ße baskƒ±n terimler oranƒ±: (3x¬≤)/(2x¬≤)=3/2. Grafik 1.5 etrafƒ±nda yatayla≈üƒ±yor.",
      microHint:
        "x ‚Üí ‚àû iken √ßizginin yakla≈ütƒ±ƒüƒ± yatay seviyeye odaklan."
    }
  ];

  // --------- State ----------
  let currentIndex = 0;
  let currentLevel = levels[0];
  let answered = false;
  let streak = 0;
  let totalCorrect = 0;
  let totalAsked = 0;
  let animationId = null;
  let speedFactor = 1.0;

  // --------- DOM ----------
  const canvas = document.getElementById("graphCanvas");
  const ctx = canvas.getContext("2d");
  const functionLabel = document.getElementById("functionLabel");
  const limitPrompt = document.getElementById("limitPrompt");
  const choicesContainer = document.getElementById("choicesContainer");
  const feedbackEl = document.getElementById("feedback");
  const explanationEl = document.getElementById("explanation");
  const levelLabel = document.getElementById("levelLabel");
  const microHintEl = document.getElementById("microHint");
  const replayBtn = document.getElementById("replayBtn");
  const nextBtn = document.getElementById("nextBtn");
  const streakEl = document.getElementById("streak");
  const totalCorrectEl = document.getElementById("totalCorrect");
  const totalAskedEl = document.getElementById("totalAsked");
  const speedRange = document.getElementById("speedRange");
  const speedLabel = document.getElementById("speedLabel");

  // --------- Speed Control ----------
  speedRange.addEventListener("input", () => {
    speedFactor = parseFloat(speedRange.value);
    speedLabel.textContent = speedFactor.toFixed(1) + "x";
  });

  // --------- Coord Transform ----------
  function worldToCanvas(x, y, lvl) {
    const { xMin, xMax, yMin, yMax } = lvl;
    const margin = 18;
    const w = canvas.width - 2 * margin;
    const h = canvas.height - 2 * margin;
    const nx = (x - xMin) / (xMax - xMin || 1);
    const ny = (y - yMin) / (yMax - yMin || 1);
    const cx = margin + Math.max(0, Math.min(1, nx)) * w;
    const cy = margin + (1 - Math.max(0, Math.min(1, ny))) * h;
    return { x: cx, y: cy };
  }

  function clearAnimation() {
    if (animationId) {
      cancelAnimationFrame(animationId);
      animationId = null;
    }
  }

  // --------- Draw Base ----------
  function drawBase(lvl) {
    const { xMin, xMax, yMin, yMax } = lvl;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const g = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
    g.addColorStop(0, "rgba(6,8,20,1)");
    g.addColorStop(1, "rgba(1,3,10,1)");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // grid
    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = "rgba(148,163,253,0.18)";
    ctx.lineWidth = 0.4;

    for (let i = Math.ceil(xMin); i <= Math.floor(xMax); i++) {
      const p = worldToCanvas(i, yMin, lvl);
      ctx.beginPath();
      ctx.moveTo(p.x, 6);
      ctx.lineTo(p.x, canvas.height - 6);
      ctx.stroke();
    }
    for (let j = Math.ceil(yMin); j <= Math.floor(yMax); j++) {
      const p = worldToCanvas(xMin, j, lvl);
      ctx.beginPath();
      ctx.moveTo(6, p.y);
      ctx.lineTo(canvas.width - 6, p.y);
      ctx.stroke();
    }
    ctx.restore();

    // axes
    ctx.save();
    ctx.strokeStyle = "rgba(148,163,253,0.7)";
    ctx.lineWidth = 0.7;

    if (yMin < 0 && yMax > 0) {
      const p1 = worldToCanvas(xMin, 0, lvl);
      const p2 = worldToCanvas(xMax, 0, lvl);
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
    }
    if (xMin < 0 && xMax > 0) {
      const p1 = worldToCanvas(0, yMin, lvl);
      const p2 = worldToCanvas(0, yMax, lvl);
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
    }
    ctx.restore();

    // ticks & labels (kƒ±sa)
    ctx.save();
    ctx.fillStyle = "rgba(148,163,253,0.78)";
    ctx.font = "7px system-ui";

    for (let i = Math.ceil(xMin); i <= Math.floor(xMax); i++) {
      const p = worldToCanvas(i, yMin, lvl);
      ctx.fillText(i.toString(), p.x - 3, canvas.height - 4);
    }
    for (let j = Math.ceil(yMin); j <= Math.floor(yMax); j++) {
      const p = worldToCanvas(xMin, j, lvl);
      ctx.fillText(j.toString(), 4, p.y + 2);
    }

    if (Number.isFinite(lvl.a)) {
      const pa = worldToCanvas(lvl.a, yMin, lvl);
      ctx.fillStyle = "rgba(56,189,248,0.98)";
      ctx.fillText("x=" + lvl.aLabel, pa.x - 10, canvas.height - 14);
    }
    if (lvl.limit != null) {
      const pl = worldToCanvas(xMin, lvl.limit, lvl);
      ctx.fillStyle = "rgba(22,163,74,0.98)";
      ctx.fillText("y‚âà" + lvl.limit, 24, pl.y - 3);
    }

    ctx.restore();

    // curve
    ctx.save();
    ctx.lineWidth = 1.6;
    ctx.strokeStyle = "rgba(56,189,248,0.96)";
    ctx.beginPath();

    const steps = 180;
    let first = true;
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      const x = xMin + t * (xMax - xMin);
      let y;

      if (lvl.type === "piecewise") {
        if (x < lvl.a) y = lvl.fnLeft(x);
        else if (x > lvl.a) y = lvl.fnRight(x);
        else y = NaN;
      } else {
        y = lvl.fn(x);
      }

      if (Number.isFinite(y)) {
        const p = worldToCanvas(x, y, lvl);
        if (first) {
          ctx.moveTo(p.x, p.y);
          first = false;
        } else {
          ctx.lineTo(p.x, p.y);
        }
      } else {
        first = true;
      }
    }
    ctx.stroke();
    ctx.restore();

    if (lvl.id === 2) {
      const hole = worldToCanvas(lvl.a, lvl.limit, lvl);
      ctx.save();
      ctx.strokeStyle = "rgba(248,250,252,0.96)";
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.arc(hole.x, hole.y, 4, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }

    if (lvl.type === "piecewise") {
      const leftY = lvl.fnLeft(lvl.a - 0.02);
      const rightY = lvl.fnRight(lvl.a + 0.02);
      const leftP = worldToCanvas(lvl.a, leftY, lvl);
      const rightP = worldToCanvas(lvl.a, rightY, lvl);

      ctx.save();
      ctx.fillStyle = "rgba(56,189,248,0.98)";
      ctx.beginPath();
      ctx.arc(leftP.x, leftP.y, 3, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "rgba(251,191,36,0.96)";
      ctx.beginPath();
      ctx.arc(rightP.x, rightP.y, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  // --------- Continuous Animation ----------
  function animateApproach(lvl) {
    clearAnimation();
    const baseDuration = 1800;

    function frame(startTime) {
      return function loop(now) {
        const elapsed = now - startTime;
        const t = ((elapsed) / (baseDuration / (speedFactor || 0.1))) % 1;

        drawBase(lvl);

        if (lvl.type === "infinity") {
          const x = lvl.xMin + t * (lvl.xMax - lvl.xMin);
          const y = lvl.fn(x);
          if (Number.isFinite(y)) {
            const p = worldToCanvas(x, y, lvl);
            ctx.save();
            ctx.fillStyle = "rgba(56,189,248,1)";
            ctx.shadowColor = "rgba(56,189,248,0.7)";
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
          if (lvl.limit != null) {
            const yLine = worldToCanvas(0, lvl.limit, lvl).y;
            ctx.save();
            ctx.setLineDash([3, 3]);
            ctx.strokeStyle = "rgba(148,163,253,0.32)";
            ctx.beginPath();
            ctx.moveTo(20, yLine);
            ctx.lineTo(canvas.width - 20, yLine);
            ctx.stroke();
            ctx.restore();
          }
        } else {
          const span = (lvl.xMax - lvl.xMin) * 0.35;
          const leftX = lvl.a - span * (1 - t);
          const rightX = lvl.a + span * (1 - t);

          let yL, yR;
          if (lvl.type === "piecewise") {
            yL = lvl.fnLeft(leftX);
            yR = lvl.fnRight(rightX);
          } else {
            yL = lvl.fn(leftX);
            yR = lvl.fn(rightX);
          }

          if (Number.isFinite(yL)) {
            const pL = worldToCanvas(leftX, yL, lvl);
            ctx.save();
            ctx.fillStyle = "rgba(56,189,248,0.98)";
            ctx.shadowColor = "rgba(56,189,248,0.9)";
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(pL.x, pL.y, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }

          if (Number.isFinite(yR)) {
            const pR = worldToCanvas(rightX, yR, lvl);
            ctx.save();
            ctx.fillStyle = "rgba(251,191,36,0.96)";
            ctx.shadowColor = "rgba(251,191,36,0.9)";
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(pR.x, pR.y, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }

          if (lvl.limit != null) {
            const target = worldToCanvas(
              Number.isFinite(lvl.a) ? lvl.a : lvl.xMax,
              lvl.limit,
              lvl
            );
            ctx.save();
            ctx.setLineDash([2, 3]);
            ctx.strokeStyle = "rgba(148,163,253,0.36)";
            ctx.beginPath();
            ctx.arc(target.x, target.y, 6, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
          }
        }

        animationId = requestAnimationFrame(loop);
      };
    }

    animationId = requestAnimationFrame(animateStart => frame(animateStart)(animateStart));
  }

  // --------- UI Setup ----------
  function renderLevel(lvl) {
    currentLevel = lvl;
    answered = false;
    feedbackEl.textContent = "";
    feedbackEl.className = "feedback";
    explanationEl.textContent = "";
    levelLabel.textContent = `Seviye ${lvl.id} ¬∑ ${lvl.title}`;
    microHintEl.textContent = lvl.microHint || "";

    functionLabel.textContent = lvl.fnLabel;
    limitPrompt.textContent =
      lvl.a === Infinity
        ? "x ‚Üí ‚àû iken f(x) hangi deƒüere yakla≈üƒ±yor?"
        : `x ‚Üí ${lvl.aLabel} iken f(x) hangi deƒüere yakla≈üƒ±yor?`;

    choicesContainer.innerHTML = "";
    lvl.options.forEach((opt, index) => {
      const btn = document.createElement("button");
      btn.className = "choice-btn";
      const labelSpan = document.createElement("span");
      labelSpan.className = "label";
      labelSpan.textContent =
        typeof opt === "string"
          ? opt
          : (Number.isInteger(opt)
              ? opt.toString()
              : opt.toString().replace(".", ","));
      const keySpan = document.createElement("span");
      keySpan.className = "key";
      keySpan.textContent = ["A", "B", "C"][index] || "";
      btn.appendChild(labelSpan);
      btn.appendChild(keySpan);
      btn.addEventListener("click", () => handleChoice(opt, btn));
      choicesContainer.appendChild(btn);
    });

    drawBase(lvl);
    animateApproach(lvl);
  }

  function handleChoice(selected, btnEl) {
    if (answered) return;
    answered = true;
    totalAsked++;

    let isCorrect = false;
    if (currentLevel.limit === null) {
      isCorrect =
        typeof selected === "string" &&
        selected.toLowerCase().includes("limit yok");
    } else {
      const correct = currentLevel.limit;
      isCorrect =
        typeof selected === "number" &&
        Math.abs(selected - correct) < 1e-6;
    }

    const allBtns = choicesContainer.querySelectorAll(".choice-btn");
    allBtns.forEach(b => (b.disabled = true));

    if (isCorrect) {
      btnEl.classList.add("correct");
      feedbackEl.textContent = "Doƒüru üéØ Limit davranƒ±≈üƒ±nƒ± doƒüru okudun.";
      feedbackEl.classList.add("ok");
      totalCorrect++;
      streak++;
    } else {
      btnEl.classList.add("wrong");
      feedbackEl.textContent = "Yanlƒ±≈ü ‚ùå Grafiƒüin yakla≈üma ≈üeklini tekrar izle.";
      feedbackEl.classList.add("bad");
      streak = 0;
    }

    allBtns.forEach(b => {
      const txt = b.querySelector(".label").textContent.replace(",", ".");
      const isNoLimit = b.textContent.toLowerCase().includes("limit yok");
      const val = parseFloat(txt);
      if (currentLevel.limit === null && isNoLimit) {
        b.classList.add("correct");
      } else if (
        currentLevel.limit !== null &&
        !isNaN(val) &&
        Math.abs(val - currentLevel.limit) < 1e-6
      ) {
        b.classList.add("correct");
      }
    });

    explanationEl.textContent = currentLevel.explanation || "";
    streakEl.textContent = streak.toString();
    totalCorrectEl.textContent = totalCorrect;
    totalAskedEl.textContent = totalAsked;
  }

  function nextLevel() {
    currentIndex = (currentIndex + 1) % levels.length;
    renderLevel(levels[currentIndex]);
  }

  // --------- Events ----------
  replayBtn.addEventListener("click", () => {
    answered = false;
    feedbackEl.textContent = "";
    feedbackEl.className = "feedback";
    explanationEl.textContent = "";
    const allBtns = choicesContainer.querySelectorAll(".choice-btn");
    allBtns.forEach(b => {
      b.disabled = false;
      b.classList.remove("correct", "wrong");
    });
    animateApproach(currentLevel);
  });

  nextBtn.addEventListener("click", nextLevel);

  // --------- Init ----------
  renderLevel(currentLevel);
</script>
</body>
</html>
